// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
)

const assignCardImageToWearLevel = `-- name: AssignCardImageToWearLevel :one
INSERT INTO card_wear_img (base_id, wear_level, image_url)
VALUES ($1, $2, $3)
ON CONFLICT (base_id, wear_level) DO UPDATE SET image_url = EXCLUDED.image_url
RETURNING base_id, wear_level, image_url
`

type AssignCardImageToWearLevelParams struct {
	BaseID    int16
	WearLevel int16
	ImageUrl  string
}

func (q *Queries) AssignCardImageToWearLevel(ctx context.Context, arg AssignCardImageToWearLevelParams) (CardWearImg, error) {
	row := q.db.QueryRow(ctx, assignCardImageToWearLevel, arg.BaseID, arg.WearLevel, arg.ImageUrl)
	var i CardWearImg
	err := row.Scan(&i.BaseID, &i.WearLevel, &i.ImageUrl)
	return i, err
}

const createCardBase = `-- name: CreateCardBase :one
INSERT INTO card_base (key, name, source, place)
VALUES ($1, $2, $3, $4)
RETURNING id, key, name, source, place
`

type CreateCardBaseParams struct {
	Key    *string
	Name   string
	Source *string
	Place  int16
}

func (q *Queries) CreateCardBase(ctx context.Context, arg CreateCardBaseParams) (CardBase, error) {
	row := q.db.QueryRow(ctx, createCardBase,
		arg.Key,
		arg.Name,
		arg.Source,
		arg.Place,
	)
	var i CardBase
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Name,
		&i.Source,
		&i.Place,
	)
	return i, err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO player (name)
VALUES ($1)
RETURNING id, name, registered, is_admin
`

func (q *Queries) CreatePlayer(ctx context.Context, name string) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer, name)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Registered,
		&i.IsAdmin,
	)
	return i, err
}

const demotePlayer = `-- name: DemotePlayer :exec
UPDATE player
SET is_admin = false
WHERE id = $1
`

func (q *Queries) DemotePlayer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, demotePlayer, id)
	return err
}

const getCardBases = `-- name: GetCardBases :many
SELECT id, key, name, source, place, base_id, wear_level, image_url
FROM card_base
         LEFT JOIN card_wear_img ON card_base.id = card_wear_img.base_id
`

type GetCardBasesRow struct {
	ID        int16
	Key       *string
	Name      string
	Source    *string
	Place     int16
	BaseID    *int16
	WearLevel *int16
	ImageUrl  *string
}

func (q *Queries) GetCardBases(ctx context.Context) ([]GetCardBasesRow, error) {
	rows, err := q.db.Query(ctx, getCardBases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCardBasesRow{}
	for rows.Next() {
		var i GetCardBasesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Name,
			&i.Source,
			&i.Place,
			&i.BaseID,
			&i.WearLevel,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCardCopy = `-- name: GetCardCopy :one
SELECT card_copy.id, card_copy.key, card_base.place, card_base.name, card_base.source, card_copy.wear_level, card_wear_img.image_url, player.name
FROM card_copy
         JOIN card_base ON card_copy.base_id = card_base.id
         JOIN card_wear_img
              ON card_copy.base_id = card_wear_img.base_id AND card_wear_img.wear_level <= card_copy.wear_level
         LEFT JOIN player ON player.id = card_copy.copied_from_player
WHERE card_copy.id = $1
ORDER BY card_wear_img.wear_level DESC
LIMIT 1
`

type GetCardCopyRow struct {
	ID        int32
	Key       string
	Place     int16
	Name      string
	Source    *string
	WearLevel int16
	ImageUrl  string
	Name_2    *string
}

func (q *Queries) GetCardCopy(ctx context.Context, id int32) (GetCardCopyRow, error) {
	row := q.db.QueryRow(ctx, getCardCopy, id)
	var i GetCardCopyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Place,
		&i.Name,
		&i.Source,
		&i.WearLevel,
		&i.ImageUrl,
		&i.Name_2,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, name, registered, is_admin
FROM player
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPlayer(ctx context.Context, id int32) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayer, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Registered,
		&i.IsAdmin,
	)
	return i, err
}

const getPlayerCards = `-- name: GetPlayerCards :many
SELECT card_copy.id, card_copy.key, card_base.place, card_base.name, card_base.source, card_copy.wear_level, card_wear_img.image_url, player.name
FROM card_copy
         JOIN card_base ON card_copy.base_id = card_base.id
         JOIN card_wear_img
              ON card_copy.base_id = card_wear_img.base_id AND card_wear_img.wear_level = (
                  SELECT MAX(cwi.wear_level)
                  FROM card_wear_img cwi
                  WHERE cwi.base_id = card_copy.base_id
                    AND cwi.wear_level <= card_copy.wear_level
              )
         LEFT JOIN player ON player.id = card_copy.copied_from_player
WHERE player_id = $1
`

type GetPlayerCardsRow struct {
	ID        int32
	Key       string
	Place     int16
	Name      string
	Source    *string
	WearLevel int16
	ImageUrl  string
	Name_2    *string
}

func (q *Queries) GetPlayerCards(ctx context.Context, playerID int32) ([]GetPlayerCardsRow, error) {
	rows, err := q.db.Query(ctx, getPlayerCards, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlayerCardsRow{}
	for rows.Next() {
		var i GetPlayerCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Place,
			&i.Name,
			&i.Source,
			&i.WearLevel,
			&i.ImageUrl,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayers = `-- name: GetPlayers :many

SELECT id, name, registered, is_admin
FROM player
`

// Player stuffs
func (q *Queries) GetPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, getPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Registered,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeFirstCopy = `-- name: MakeFirstCopy :one
INSERT INTO card_copy (player_id, base_id, key)
VALUES ($1,
        (SELECT id FROM card_base WHERE card_base.key = $2 AND card_base.key IS NOT NULL),
        random_string(10))
ON CONFLICT (player_id, base_id) DO UPDATE SET wear_level = 0, copied_from_player = NULL
RETURNING id, player_id, base_id, copied_from_player, timestamp, wear_level, key
`

type MakeFirstCopyParams struct {
	PlayerID int32
	Key      *string
}

func (q *Queries) MakeFirstCopy(ctx context.Context, arg MakeFirstCopyParams) (CardCopy, error) {
	row := q.db.QueryRow(ctx, makeFirstCopy, arg.PlayerID, arg.Key)
	var i CardCopy
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.BaseID,
		&i.CopiedFromPlayer,
		&i.Timestamp,
		&i.WearLevel,
		&i.Key,
	)
	return i, err
}

const makeSubsequentCopy = `-- name: MakeSubsequentCopy :one
WITH t AS (SELECT src.base_id, src.player_id, (src.wear_level + 1) AS new_wear_level
           FROM card_copy AS src
           WHERE src.key = $2)
INSERT
INTO card_copy (player_id, base_id, copied_from_player, wear_level, key)
VALUES ($1,
        (SELECT base_id FROM t),
        (SELECT t.player_id FROM t),
        (SELECT new_wear_level FROM t),
        random_string(10)) -- hopefully this does not result in a conflict
ON CONFLICT (player_id, base_id) DO UPDATE SET wear_level = EXCLUDED.wear_level
WHERE card_copy.wear_level > EXCLUDED.wear_level
RETURNING id, player_id, base_id, copied_from_player, timestamp, wear_level, key
`

type MakeSubsequentCopyParams struct {
	PlayerID int32
	Key      string
}

func (q *Queries) MakeSubsequentCopy(ctx context.Context, arg MakeSubsequentCopyParams) (CardCopy, error) {
	row := q.db.QueryRow(ctx, makeSubsequentCopy, arg.PlayerID, arg.Key)
	var i CardCopy
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.BaseID,
		&i.CopiedFromPlayer,
		&i.Timestamp,
		&i.WearLevel,
		&i.Key,
	)
	return i, err
}

const promotePlayer = `-- name: PromotePlayer :exec
UPDATE player
SET is_admin = true
WHERE id = $1
`

func (q *Queries) PromotePlayer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, promotePlayer, id)
	return err
}
